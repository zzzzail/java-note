package TheArtOfJavaConcurrencyProgramming.Section05;

import java.security.AccessControlContext;
import java.security.AccessController;

/**
 * @author zail
 * @since 2018-09-07
 */
public class ThreadSource {
  
  private String name;
  
  // private void init(ThreadGroup g, Runnable target, String name,
  //                   long stackSize, AccessControlContext acc,
  //                   boolean inheritThreadLocals) {
  //   if (name == null) {
  //     throw new NullPointerException("name cannot be null");
  //   }
  //
  //   this.name = name;
  //
  //   // 当前线程就是该线程的父线程
  //   Thread parent = currentThread();
  //   SecurityManager security = System.getSecurityManager();
  //   if (g == null) {
  //     /* Determine if it's an applet or not */
  //
  //           /* If there is a security manager, ask the security manager
  //              what to do. */
  //     if (security != null) {
  //       g = security.getThreadGroup();
  //     }
  //
  //           /* If the security doesn't have a strong opinion of the matter
  //              use the parent thread group. */
  //     if (g == null) {
  //       g = parent.getThreadGroup();
  //     }
  //   }
  //
  //       /* checkAccess regardless of whether or not threadgroup is
  //          explicitly passed in. */
  //   g.checkAccess();
  //
  //   /*
  //    * Do we have the required permissions?
  //    */
  //   if (security != null) {
  //     if (isCCLOverridden(getClass())) {
  //       security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
  //     }
  //   }
  //
  //   g.addUnstarted();
  //
  //   this.group = g;
  //   this.daemon = parent.isDaemon();
  //   this.priority = parent.getPriority();
  //   if (security == null || isCCLOverridden(parent.getClass()))
  //     this.contextClassLoader = parent.getContextClassLoader();
  //   else
  //     this.contextClassLoader = parent.contextClassLoader;
  //   this.inheritedAccessControlContext =
  //     acc != null ? acc : AccessController.getContext();
  //   this.target = target;
  //   setPriority(priority);
  //   if (inheritThreadLocals && parent.inheritableThreadLocals != null)
  //     this.inheritableThreadLocals =
  //       ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
  //   /* Stash the specified stack size in case the VM cares */
  //   this.stackSize = stackSize;
  //
  //   /* Set thread ID */
  //   tid = nextThreadID();
  // }
  
}
