package org.teiba.java.dsa.sort;

import java.util.Arrays;

/**
 * 冒泡排序
 * <p>
 * 1.冒泡排序是原地排序算法吗？
 * 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，
 * 所以它的空间复杂度为 O(1)，是一个原地排序算法。
 * 2.冒泡排序是稳定的排序算法吗？
 * 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保
 * 证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，
 * 我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒
 * 泡排序是稳定的排序算法。
 * 3.冒泡排序的时间复杂度是多少？
 * 最好情况下，要排序的数据已经是有序的了，我们只需要进行一次
 * 冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。
 * 而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n
 * 次冒泡操作，所以最坏情况时间复杂度为 O(n^2)。
 *
 * @author zail
 * @date 2020/7/14
 */
public class BubbleSortDemo02 {
    
    public static void main(String[] args) {
        int[] arr = new int[]{3, 2, 1, 6, 5, 4};
        arr = sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    
    /**
     * 冒泡排序
     * <p>
     * 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，
     * 看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移
     * 动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。
     * -------------------------------------------------------------------------------------
     * |  [ 4 5 6 3 2 1 ]
     * |    ↑_↑
     * |  [ 4 5 6 3 2 1 ]
     * |      ↑_↑
     * |  [ 4 5 6 3 2 1 ]
     * |        ↑_↑         // 3比6小，把这两个值交换一下，让小的值在前面
     * |  [ 4 5 3 6 2 1 ]
     * |          ↑_↑
     * |  [ 4 5 3 2 6 1 ]
     * |            ↑_↑
     * |  [ 4 5 3 2 1 6 ]
     * |    ↑_↑
     * |  [ 4 5 3 2 1 6 ]
     * |      ↑_↑
     * |  [ 4 3 5 2 1 6 ]
     * |        ↑_↑
     * |  [ 4 3 2 5 1 6 ]
     * |          ↑_↑
     * |  [ 4 3 2 1 5 6 ]
     * |            ↑_↑
     * |  [ 4 3 2 1 5 6 ]
     * |    ↑_↑
     * |  [ 3 4 2 1 5 6 ]
     * |      ↑_↑
     * |  [ 3 2 4 1 5 6 ]
     * |        ↑_↑
     * |  [ 3 2 1 4 5 6 ]
     * |          ↑_↑
     * |  [ 3 2 1 4 5 6 ]
     * |            ↑_↑
     * |  [ 3 2 1 4 5 6 ]
     * |    ↑_↑
     * |  [ 2 3 1 4 5 6 ]
     * |      ↑_↑
     * |  [ 2 1 3 4 5 6 ]
     * |        ↑_↑
     * |  [ 2 1 3 4 5 6 ]
     * |          ↑_↑
     * |  [ 2 1 3 4 5 6 ]
     * |            ↑_↑
     * |  [ 2 1 3 4 5 6 ]
     * |    ↑_↑
     * |  [ 1 2 3 4 5 6 ]
     * |  ...
     * ----------------------------------------------------------------------------------------
     *
     * @param arr 需要排序的数组
     * @return
     */
    public static int[] sort(int[] arr) {
        if (arr == null) {
            return null;
        }
        
        int n = arr.length;
        if (n <= 1) {
            return arr;
        }
        
        for (int i = 0; i < n; i++) {
            
            // 冒泡排序是可以提前结束的。如果一次排序中没有交换过任何数据，则说明已排序完成。
            // 标记冒泡排序提前结束
            boolean flag = false;
            
            for (int j = 0; j < n - i - 1; j++) {
                // 如果前面的值比后面的值大，则交换
                if (arr[j] > arr[j + 1]) {
                    int t = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = t;
                    flag = true;
                }
            }
            
            // 如果flag为false说明没有进行数据交换
            if (!flag) {
                break;
            }
        }
        
        return arr;
    }
    
}
