package org.teiba.java.dsa.sort;

import java.util.Arrays;

/**
 * 插入排序
 * 我们先来看一个问题。一个有序的数组，我们往里面添加一个新的数据后，如何继续保
 * 持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。
 * ----------------------------------------------------------------------------------------------
 * |  [ 1 7 8 13 ]     <--   插入6
 * |  [ 1   7 8 13]    数据迁移
 * |  [ 1 6 7 8 13]    插入6之后
 * ----------------------------------------------------------------------------------------------
 * 这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保
 * 持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，
 * 来进行排序，于是就有了插入排序算法。
 * <p>
 * 那插入排序具体是如何借助上面的思想来实现排序的呢？
 * <p>
 * 首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只
 * 有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在
 * 已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个
 * 过程，直到未排序区间中元素为空，算法结束。
 * <p>
 * 1.插入排序是原地排序算法吗？
 * 从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间
 * 复杂度是 O(1)，也就是说，这是一个原地排序算法。
 * <p>
 * 2.插入排序是稳定的排序算法吗？
 * 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元
 * 素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
 * <p>
 * 3.插入排序的时间复杂度是多少？
 * 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序
 * 数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况
 * 下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。
 * <p>
 * 如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动
 * 大量的数据，所以最坏情况时间复杂度为 O(n^2)。
 * <p>
 * 还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，
 * 对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入
 * 操作，所以平均时间复杂度为 O(n^2)。
 *
 * @author zail
 * @date 2020/7/14
 */
public class InsertionSortDemo01 {
    
    public static void main(String[] args) {
        Integer[] arr = new Integer[]{4, 5, 6, 1, 2, 3};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    
    /**
     * 插入排序
     *
     * @param arr
     */
    public static void sort(Comparable[] arr) {
        
        if (arr == null) {
            return;
        }
        
        int n = arr.length;
        
        for (int i = 1; i < n; ++i) {
            Comparable value = arr[i];
            int j = i - 1;
            for (; j >= 0; --j) {
                if (arr[j].compareTo(value) > 0) {
                    // 数据向后移动
                    arr[j + 1] = arr[j];
                } else {
                    break;
                }
            }
            // 插入数据
            arr[j + 1] = value;
        }
        
    }
    
}
